{
    "collab_server" : "",
    "contents" : "install.packages(\"monitoR\")\nlibrary(monitoR)\ndata(\"survey\")\nsurvey\n\n#View the spectogram of the recording:\nviewSpec(survey)\n\n#Play the sound in R, after having installed the \n#command-line wav player SoundExchange (aka SoX):\n#\"brew install sox\" from bash.\n#The player itself is named 'play'.\nsetWavPlayer(\"play\")\nplay(survey)\n\n#Add clips of BTNW & OVEN:\ndata(btnw)\ndata(oven)\nviewSpec(btnw)\n\n#As Wave objects, these recordings can be used directly in the template matching functions.\n#Users will typically work with wav files, however, as opposed to mp3 files, or Wave objects. To be\n#consistent with this typical approach, we will save the two clips and the survey as wav files.\n#We’ll include a made-up date in the name for the survey file, since that is one way to determine “absolute”\n#times for detections\n\nbtnw.fp <- file.path(tempdir(), \"btnw.wav\")\noven.fp <- file.path(tempdir(), \"oven.wav\")\nsurvey.fp <- file.path(tempdir(), \"survey2010-12-31_120000_EST.wav\")\nwriteWave(btnw, btnw.fp) #This is recreating a Wave file, as would be downloaded from the recorder.\nwriteWave(oven, oven.fp)\nwriteWave(survey, survey.fp)\n\n#Spectogram cross correlation.\n## The easiest way to create a correlation template is to call makeCorTemplate with only the 'clip'\n## argument specified (here I added the \"name\" argument because the resulting template is put into \n## a list and automatically given the name \"A\", which isn't informative.The makeCorTemplate function \n## displays a spectrogram of the recording and shows the cells included in the template in transparent \n## purple:\nwct1 <- makeCorTemplate(btnw.fp, name = \"w1\")\n\n#Review the template:\nwct1\n\n## This template is functional, but it does not take advantage of all the options available in \n## makeCorTemplate.Setting time and frequency limits is one of simplest, and may be necessary when \n## making a template from a long recording. We’ll make a new template that uses the t.lim and frq.lim \n## arguments to focus on a particular section within the song.\nwct2 <- makeCorTemplate(btnw.fp, t.lim = c(1.5, 2.1), frq.lim = c(4.2, 5.6), name = \"w2\")\ntemplateNames(wct2) <- \"NewName\" #you can also change the name of the template after the fact.\n\n#Ovenbird templates:\noct1 <- makeCorTemplate(oven.fp, t.lim = c(1,4), frq.lim = c(1,11), name = \"o1\")\n#Another useful step is to adjust the number of points included with the 'dens' argument:\noct2 <- makeCorTemplate(oven.fp, t.lim = c(1,4), frq.lim = c(1,11), dens = 0.1, name = \"o2\")\noct1;oct2 #notice that oct2 has ~10% of the number of points included as oct1.\n\n## monitoR is designed to use template lists that contain multiple templates. \n## Templates can be combined together in a single list with combineCorTemplates.\nctemps <- combineCorTemplates(wct1, wct2, oct1, oct2)\nctemps\ntemplateNames(ctemps)[2] <- \"w2\" #change the name back to match the tutorial :)\nctemps\nplot(ctemps)\n\n## We can now use our templates to look for black-throated green warbler and ovenbird songs within\n## the survey recording. This is a three-step process: \n## 1) we first calculate correlation score between the templates and each time bin in the survey, \n## 2) then identify “peaks” in the scores, and \n## 3) finally determine which, if any, score peaks exceed the score cutoff. \n## Correlation scores are calculated with corMatch.\n\ncscores <-corMatch(survey = survey.fp, templates = ctemps, parallel = T, show.prog = TRUE,\n                   cor.method = \"pearson\")\ncscores\n\n##  To make detections, we need to look within the correlation scores returned by\n## corMatch for peaks, and then identify those peaks with values above the score cutoff as detections.\n## These two steps are carried out with findPeaks.\n\ncdetects <- findPeaks(score.obj = cscores, parallel = T)\n\n## From the n.peaks column, we can see there are from five to 38 peaks per template, and from the\n## n.detections column, we can see that the templates resulted in from one to three detections:\ncdetects\n\n## The detections can be extracted with the getDetections function:\ngetDetections(cdetects)\n\n## If you only wanted a single template, use 'which.one':\ngetDetections(detection.obj = cdetects, which.one = \"w1\")\n\n## Whether or not a peak qualifies as a detection depends a parameter called the score cutoff, which can\n## be set separately for each template. If we look at our template list again, we can see the score cutoffs\n## given in the last column of the summary.\nctemps\n\n## They are currently set to the default value of 0.4. No reason to think that this value should\n## work for all or even any templates. Instead, score cutoffs need to be determined based on template\n## performance, typically with a subset of the survey or surveys that will ultimately be searched for\n## matching sounds. Here we just have one, very short, survey, so we’ll use the entire survey to determine\n## what the score cutoff should be set to for each template. We can see a graphical summary of the\n## results with the generic plot function.\nplot(cdetects)\n\n## Both Ovenbird templates work well. The BTNW templates perform differently, though, with the second\n## template apparently better than the first. The peaks for the second template are higher during actual\n## songs and lower during non-singing periods. It seems like reducing the frequency over which the template\n## occurs helps.For narrow-banded songs, this would be a good strategy.\n\n## We can also see that reducing the score cutoff would reduce errors of omission - for example, the peak\n## for the faint song of the Ovenbird is missed with a 0.4 cutoff, but would be detected at a 0.2 cutoff.\n\n## To change the cutoff without re-running the previous steps:\ntemplateCutoff(ctemps)\ntemplateCutoff(ctemps)[1:4] <- c(w1 = 0.2, w2 = 0.3, o1 = 0.2, o2 = 0.2)\n#or, more efficiently: templateCutoff(ctemps) <- c(w2 = 0.3, default = 0.2)\n\n#the 'cdetects' file is automatically updated!\ncdetects\n\n## Since the template w1 is nearly useless, and template o1 and o2 nearly identical, we might want to\n## drop w1 and either o1 or o2 from our results.\ncdetects <- cdetects[c(\"w2\",\"o2\")]\ncdetects\n\nshowPeaks(detection.obj = cdetects, which.one = 'w2', point = T, scorelim = c(0,1),\n          verify = TRUE, what = \"detections\", player = \"play\")\n\nviewSpec(survey, interactive = TRUE, annotate = TRUE)\n\n\n",
    "created" : 1504290171222.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2596226982",
    "id" : "BF9247A5",
    "lastKnownWriteTime" : 1504904418,
    "last_content_update" : 1504904418629,
    "path" : "~/GitHub/BITH_Maine/monitorTutorial.R",
    "project_path" : "monitorTutorial.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}